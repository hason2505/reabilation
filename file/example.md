# 人工智能程序设计语言  

# 2.1 概述  

我们知道，人工智能所解决的问题并非一般的数值计算或数据处理问题。所以，用常规的程序设计语言进行人工智能程序设计，就显得不那么得心应手。于是，面向人工智能程序设计的语言便应运而生。  

第一个人工智能程序设计语言是表处理语言LISP(LIStProcessing 的缩写）。它于1960年由美国麻省理工学院的麦卡锡（John Macarthy)和他的研究小组首先设计实现。正如其名称所示，LISP最擅长表处理，亦即符号处理。半个多世纪以来，它在人工智能领域中发挥了非常重要的作用，许多著名的人工智能系统都是用LISP语言编写的。LISP被誉为人工智能的数学，至今仍然是人工智能研究和开发的主要工具之一。  

现在，人工智能程序设计语言已有了很大的进步和发展。继LISP之后，还相继出现了 PROLOG、C++、Java、MATLAB、Python 等语言。概括起来,面向人工智能程序设计的语言包括函数型、逻辑型、面向对象型、计算型及混合型等多种类型。  

# 2.1.1 函数型语言  

LISP是一种函数型程序设计语言。LISP程序由一组函数组成，程序的执行过程就是一系列的函数调用和求值过程。但LISP还不是纯函数型语言，准确地讲，它是基于入-函数的语言。除LISP外,20 世纪7O 年代，J.Backus 还提出了一种被称为FP 的所谓纯函数型程序设计语言。  

# 2.1.2 逻辑型语言  

逻辑型程序设计语言起源于 PROLOG(PROgramming in LOGic 的缩写）。PROLOG首先由法国马赛大学的Colmerauer 和他的研究小组于1972 年研制成功，后来在欧洲得到进一步发展。特别是1981年日本宣布要以PROLOG 作为他们正在研制的新一代计算机——智能计算机的核心语言，更使PROLOG 举世瞩目，迅速风靡世界，成为与LISP并驾齐驱的甚至更加流行的智能程序设计语言。  

由于PROLOG语言是一种逻辑型程序设计语言，因此用它编写的程序也就是逻辑程序，即在PROLOG 程序中一般不需告诉计算机"怎么做”，而只需告诉它“做什么”。因此，PROLOG亦属陈述性语言。与通常的过程性程序设计语言相比，PROLOG可以说是更高级的语言。  

PROLOG 语言是以Horn子句逻辑为基础的程序设计语言，它是最具代表性的一种逻辑程序设计语言。早期的 PROLOG 版本都是解释型的。1986 年，美国的 Borland 公司推出了编译型 PROLOG——Turbo PROLOG,并很快成为 PC 机上流行的 PROLOG。现在则有运行在 Windows 和 Linux 环境下的 Visual PROLOG 和 Linux下的 SWIProlog。但这些 PROLOG 语言版本属顺序逻辑程序设计语言。为了进一步提高运行效率和推理速度，从20世纪80 年代初起，人们开始研制并行逻辑程序设计语言。现在已开发出了不少并行逻辑语言，其中比较著名和成熟的有PARLOG（PARallelLOGicalprogramming language)、Concurrent PROLOG、GHC(Guarded Horn Clauses)等。  

# 2.1.3 面向对象语言  

自 20 世纪 80 年代以来,面向对象程序设计（object-oriented programming,OOP)异军突起，发展迅速，并越来越流行起来。面向对象程序以其信息隐蔽、封装、继承、多态、消息传递等一系列优良机制，大大改善了软件的复杂性、模块性、重用性和可维护性，有望从根本上解决软件的生产效率问题。另一方面，由于面向对象程序设计的类、对象、继承等概念，与人工智能，特别是知识表示和知识库产生了联系。因而，面向对象程序设计语言也成为一种人工智能程序设计语言，而被广泛引入人工智能程序设计，特别是知识工程、专家系统程序设计。  

面向对象程序设计语言种类繁多，已发展成为一个大家族。其中最纯正、最具面向对象风格的语言当推 Smalltalk,而最流行的是C++。此外,Java 是适于网络(Internet)环境的一种面向对象语言。  

# 2.1.4 计算型语言  

所谓计算型语言，就是面向数值计算的程序设计语言。最典型的计算型语言就是MATLAB。计算型语言属于过程性语言，长于描述算法，而且本身又自带算法库，所以是机器学习的常用编程语言。另外，在机器学习领域还有一些流行的编程语言，如R、Python、Java、WEKA、GO、JavaScript、Scala、Darknet 等,也可看作计算型语言，虽然它们有些同时也是面向对象语言。  

# 2.1.5 混合型语言  

以上几种语言都各有所长，但也都有其不足之处。为了扬长避短，便出现了基于这几  

种语言的混合型语言。  

# 1.函数型与逻辑型相结合的语言  

函数型与逻辑型语言的结合方式有耦合型和统一型两类。统一型又可分为具有归结语义的函数型语言和集成式语言两个子类。  

耦合型语言意为将具有归约语义的函数型语言和具有归结语义的逻辑型语言组合  
在一起,并在二者之间提供一个接口而形成的一种混合型语言。其典型代表有以下  
3种。（1）LOGLISP,该语言在LISP 的基础上增加了表达合一、回溯等机制的系统函数，  
从而在保持LISP特色的同时又有了逻辑程序设计能力。（2）FUNLOG,该语言在PROLOG之外又增加了函数定义机制，系统以归结语义执  
行PROLOG程序，以归约语义求解函数。（3）POPLOG,这是 POP-11、PROLOG 和LISP 的混合型语言,3 种成分各有一个增  
量式编译器。具有归结语义的函数型语言又可分为N-语言、F-语言和R-语言。集成式语言对函数成分和逻辑成分平等看待，并把它们对称地组织起来。其典型代  

表有LEAF和APPLOG。  

# 2.函数型与面向对象相结合的语言  

在LISP语言的基础上再扩充面向对象机制而产生的语言，被称为函数型的面向对象程序设计语言(也称为面向对象的LISP)。这种语言现已成为一个家族，其中比较著名的有以下6种。  

（1）Flavors，由 MIT 的Lisp Machine 小组于1979 年研制而成，它的基语言是 Symbolics  
Common LISP.(2）LOOPS(Lisp Object-Oriented Programming System),它是在 InterLisp-D 环境  
上实现的基于LISP的OOP语言，由Xerox公司于1983年推出。（3）CommonLoops,它是基于 CommonLisp 的函数型 OOP 语言，由 Xerox 公司于  
1985 年推出。（4）CLOS(CommonLisp Object System),它是 Xerox 公司于 1986 年推出的一个  
CommonLoops与NewFlavors 的后继产品。（5）CommonObjects,它是由HP 公司于1983—1985 年实现的又一个基于CommonLisp  
的OOP语言。（6）OBJ2，也是一种面向对象的函数型语言。  

# 3.逻辑型与面向对象相结合的语言  

著名的逻辑型与面向对象相结合的语言有以下3种。  

（1）SPOOL，该语言是日本IBM分部于1985年推出的以面向对象思想扩充的PROLOG语言。  

（2）Orient84K，该语言是Keio 大学于1984 年发表的基于PROLOG 和 Smalltalk的并行执行语言。（3）Vulan,该语言是一种面向对象的逻辑型语言。  

# 4.计算型与面向对象型相结合的语言  

典型的计算型与面向对象型相结合的语言如Python。  

以上综述了人工智能程序设计语言概况。下面将进一步介绍 PROLOG 语言和Python 语言，以便为书中后面的章节提供一个具体的语言工具，以提高有关内容的可理解性和可操作性。另一方面，这两种语言也是学习和研发人工智能的经典和流行语言工具。  

# 2.2 知识工程经典语言PROLOG  

PROLOG语言是一种基于Horn子句的逻辑型程序设计语言，也是一种陈述性语言。PROLOG与人工智能的知识表示、自动推理、图搜索、产生式系统和专家(知识)系统等有着天然的联系，很适合智能程序设计。故本书把PROLOG 语言作为例程语言。  

# 2.2.1 PROLOG 的语句  

PROLOG语言仅有3种语句，称为事实、规则和问题。  

# 1．事实(Fact)  

格式 (谓词名>((项表>).  

其中谓词名是以小写英文字母开头的字母、数字、下画线等组成的字符串，项表是以逗号隔开的项序列。PROLOG中的项包括由常量或变量表示的简单对象以及函数、结构和表等,即事实的形式是一个原子谓词公式。例如：  

student(john).   
like(mary, music).  

就是PROLOG中的两个合法事实。  

功能一般表示对象的性质或关系。  
例如上面的两个事实就分别表示"约翰是学生"和"玛丽喜欢音乐”。  
作为特殊情形，一个事实也可以只有谓词名而无参量。例如：abc.  
repeat.  

等也是允许的。  

2．规则（Rule)  

格式 (谓词名>(项表>)：-(谓词名>(项表>){,<谓词名>((项表>}.  

其中"：-"号表示"if"(也可以直接写为if)，其左部的谓词是规则的结论(也称为头)，右部的谓词是规则的前提(也称为体)，（）表示零次或多次重复，逗号表示and(逻辑与)，即规则的形式是一个逻辑蕴含式。例如：  

bird(X):- animal(X),has(X,feather).   
grandfather(X,Y):- father(X,Z),father(Z,Y).  

就是PROLOG的合法规则。  

功能一般表示对象间的因果关系、蕴含关系或对应关系。  

例如，上面的第一条规则表示"如果X是动物，并且有羽毛，则又是鸟”；第二条规则表示"X是丫的祖父，如果存在Z,X是乙的父亲并且Z是丫的父亲”。  

作为特殊情形，规则中的谓词也可以只有谓词名而无参量。例如：  

run:- start,step1(X),step2(X),end.也是一个合法规则。  

# 3．问题（Question)  

格式？－ (谓词名>(项表>){,(谓词名>((项表>)}.  

例如： ?- student(john). ?- like(mary,X).  

就是两个合法的问题。  

功能表示用户的询问，它就是程序运行的目标。  

例如，上面的第一个问题的意思是"约翰是学生吗？”,第二个问题的意思是“玛丽喜欢谁？”。  

问题可以与规则及事实同时一起给出，也可以在程序运行时临时给出。  

# 2.2.2 PROLOG的程序  

PROLOG程序一般由一组事实、规则和问题组成。问题是程序执行的起点，称为程序的目标。例如下面就是一个PROLOG程序。  

likes(bell, sports).   
likes(mary, music).   
likes(mary, sports).   
likes(jane, smith).   
friend(john,X):- likes(X,reading),likes(X,music). friend(john,X):- likes( ${\tt X},$ sports),likes(X,music).   
? - friend( john,Y) .  

可以看出，这个程序中有4条事实、2条规则和1个问题。其中事实、规则和问题都分行书写。规则和事实可连续排列在一起，其顺序可随意安排，但同一谓词名的事实或规则必须集中排列在一起。问题不能与规则及事实排在一起，它作为程序的目标要么单独列出，要么在程序运行时临时给出。  

这个程序的事实描述了一些对象(包括人和事物)间的关系；而规则则描述了John交朋友的条件，即如果一个人喜欢读书并且喜欢音乐(或者喜欢运动和喜欢音乐)，则这个人就是John 的朋友（当然，这个规则也可看作是John朋友的定义)；程序中的问题是"约翰的朋友是谁？”。  

PROLOG程序中的目标还可以变化,也可以含有多个语句(上例中只有一个)。如果有多个语句，则这些语句被称为子目标。例如对上面的程序，其问题也可以是：  

或或或  

? - likes(bell, sports), likes(mary, music),friend(john, X).  

等等。但对于不同的问题，程序运行的结果一般是不一样的。  

还需说明的是，PROLOG程序中的事实或规则一般被称为它们对应谓词的子句。例如上面程序中的前4句都是谓词likes 的子句。PROLOG 规定，同一谓词的子句应排在一起。从语句形式和程序组成来看,PROLOG 就是一种基于Horn 子句的逻辑程序。这种程序要求用事实和规则来求证询问，即证明所给出的条件子句和无条件子句与目标子句是矛盾的，或者说程序中的子句集是不可满足的。这就是所谓的PROLOG 的说明性语义。  

从 PROLOG 的语句来看，PROLOG语言的文法结构相当简单。但由于它的语句是Horn 子句，而 Horn子句的描述能力是很强的，所以PROLOG 的描述能力也很强。例如，当它的事实和规则描述的是某一学科的公理，那么问题就是待证的命题；当事实和规则描述的是某些数据和关系，那么问题就是数据查询语句；当事实和规则描述的是某领域的知识，那么问题就是利用这些知识求解的问题；当事实和规则描述的是某初始状态和状态变化规律，那么问题就是目标状态。所以,PROLOG 语言实际是一种应用相当广泛的智能程序设计语言。从上面最后一个目标可以看出，同过程性语言相比，一个PROLOG程序,其问题相当于主程序，其规则相当于子程序，而其事实则相当于数据。  

# 2.2.3 PROLOG程序的运行机理  

首先引入几个基本概念。  

# 1）自由变量与约束变量  

PROLOG中称无值的变量为自由变量，有值的变量为约束变量。一个变量取了某值就说该变量约束于某值，或者说该变量被某值所约束，或者说该变量被某值实例化了。在程序运行期间，一个自由变量可以被实例化而成为约束变量，反之，一个约束变量也可被解除其值而成为自由变量。  

# 2）匹配合一  

两个谓词可匹配合一，是指两个谓词的名相同，参量项的个数相同，参量类型对应相同，并且对应参量项还满足下列条件之一：  

$\textcircled{1}$ 如果两个都是常量，则必须完全相同；  
$\textcircled{2}$ 如果两个都是约束变量，则两个约束值必须相同；  
③ 如果其中一个是常量，一个是约束变量，则约束值与常量必须相同。  
$\textcircled{4}$ 至少有一个是自由变量。  
例如，下面的两个谓词：pre1("ob1","ob2",Z).  
prel("ob1",X,Y).  

只有当变量X被约束为ob2，且Y、Z的约束值相同或者至少有一个是自由变量时，它们才是匹配合一的。  

PROLOG 的匹配合一，与归结原理(见5.2节)中的合一的意思基本一样。但这里的合一还是一种操作。这种操作可使两个能匹配的谓词合一起来，即为参加匹配的自由变量和常量，或者两个自由变量建立一种对应关系，使得常量作为对应变量的约束值，使得两个对应的自由变量始终保持一致，即若其中一个被某值约束，则另一个也被同一值约束；反之，若其中一个的值被解除，则另一个的值也被解除。  

# 3）回溯  

所谓回溯，就是在程序运行期间，当某一个子目标不能满足(即谓词匹配失败)时，控制就返回到前一个已经满足的子目标(如果存在的话)，并撤销其有关变量的约束值，然后再使其重新满足。成功后，再继续满足原子目标。如果失败的子目标前再无子目标，则控制就返回到该子目标的上一级目标(即该子目标谓词所在规则的头部)使它重新匹配。回溯也是PROLOG的一个重要机制。  

下面介绍PROLOG程序的运行过程。仍以上面的程序为例。设所给的询问是  

?- friend(john, Y). (John和谁是朋友？)  

则求解目标为：  

friend( john, Y).  

这时，系统对程序进行扫描，寻找能与目标谓词匹配合一的事实或规则头部。显然，程序中前面的4条事实均不能与目标匹配，而第五个语句的左端即规则  

friend(john, X):- likes(X,reading),likes(X, music).  

的头部可与目标谓词匹配合一。但由于这个语句又是一个规则，所以其结论要成立则其前提必须全部成立。于是，对原目标的求解就转化为对新目标  

$$
\mathrm{1ikes(x,reading),1ikes(x,music).}
$$  

的求解。这实际是经归结，规则头部被消去，而目标子句变为 ?-likes(X,reading),likes(X, music).  

现在依次对子目标  

likes(X,reading)和 likes(X,music) 求解。  

子目标的求解过程与主目标完全一样，也是从头对程序进行扫描，不断进行测试和匹配合一等，直到匹配成功或扫描完整个程序为止。  

可以看出，对第一个子目标like(X,reading)的求解因无可匹配的事实和规则而立即失败，进而导致规则  

friend(john, X):- likes(X,reading),likes(X,music).  

的整体失败。因此，刚才的子目标likes(X,reading)和 likes(X,music)  

被撤销，系统又回溯到原目标friend(john,X)。这时，系统从该目标刚才的匹配语句处(即第五句)向下继续扫描程序中的子句，试图重新使原目标匹配，结果发现第六个语句的左部，即规则  

的头部可与目标为谓词匹配。但由于这个语句又是一个规则，因此，这时对原目标的求解，就又转化为依次对子目标  

likes(X, sports)和 likes(X, music)  

的求解。这次,子目标likes(X,sports)与程序中的事实立即匹配成功，且变量X被约束为 bell。于是，系统便接着求解第二个子目标。由于变量X已被约束，因此这时第二个子目标实际上已变成了  

likes(bell, music).  

又由于程序中不存在事实 likes(bell,music)，因此该目标的求解失败。于是，系统就放弃这个子目标，并使变量X恢复为自由变量，然后回溯到第一个子目标，重新对它进行求解。此时，系统已经记住了刚才已同第一子目标谓词匹配过的事实的位置，在重新求解时，便从下一个事实开始测试。当测试到程序中第三个事实时，第一个子目标便求解成功，且变量X被约束为 mary。这样,第二个子目标也就变成了  

likes(mary, music).  

再对它进行求解。这次很快成功。  

由于两个子目标都求解成功，所以，原目标 friend(john，Y)也成功，且变量Y被约束为 mary(由 $\mathrm{\DeltaY}$ 与X的合一关系)。于是，系统回答：  

$\mathtt{Y}=$ mary  

程序运行结束。上述程序的执行过程可图示如下(见图2-1)。  

![](https://cdn-mineru.openxlab.org.cn/extract/e7f5ce89-3c66-46b1-81e6-f73416bda03b/061d5764026d91f6c6ccfb3895cdafcce0bb9c92b71ae8d56d6bbde5ba6c4bbc.jpg)  
图2-1PROLOG程序运行机理图解示例  
视频讲解  

上述程序的运行是一个通过推理实现的求值过程。我们也可以使它变为证明过程。例如，把上述程序中的询问改为  

则系统会回答：yes。  

若将询问改为：  

则系统会回答：no。  

从上述程序的运行过程来看，PROLOG程序的执行过程是一个(归结)演绎推理过程。其推理方式为反向推理，控制策略是深度优先且有回溯机制，具体实现方法是：自上而下匹配子句；从左向右选择子目标；(归结后)产生的新子目标总是插入被消去的目标处（即目标队列的左部)。PROLOG 的这种归结演绎方法被称为 SLD(Linear resolutionwith Selection function for Definite clause)归结，或 SLD 反驳-消解法。这样,SLD 归结就是PROLOG程序的运行机理，它也就是所谓的PROLOG语言的过程性语义。  
